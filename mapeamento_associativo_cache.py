# -*- coding: utf-8 -*-
"""Mapeamento Associativo Cache.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bJRVJ-gD8T7NwU6of4yIxRZdA2H9MT-T
"""

import random
from collections import deque, defaultdict

class CacheAssociativa:
    def __init__(self, tamanhoCache, tamanhoRam, politica='LRU'):
        self.tamanhoCache = tamanhoCache
        self.tamanhoRam = tamanhoRam
        self.ram = {i: random.randint(0, 100) for i in range(tamanhoRam)}
        self.cache = {}
        self.politica = politica.upper()

        self.lru = deque() # Cria uma fila com o método deque(),
        self.fifo = deque() # Cria uma fila com o método deque()
        self.lfu = defaultdict(int)  # Usa o defaultdict para fazer uma contagem de uso por endereço

    def printCache(self):
        print("\n      Cache")
        print("Endereço | Valor")
        print("-----------------")
        for k, v in self.cache.items():
            print(f"{k:^8} | {v:^5}")

    def printRam(self):
        print("\n        RAM")
        print("Endereço | Valor")
        print("-----------------")
        for k, v in self.ram.items():
            print(f"{k:^8} | {v:^5}")




    def buscarEndereço(self, endereco, valor=None):
        print(f"\nBuscando endereço: {endereco}")
        if endereco in self.cache:
            print("Cache HIT")
            if valor is not None:
                self.cache[endereco] = valor
                self.ram[endereco] = valor
            self.aplicarPolitica(endereco)
        else:
            print("Cache MISS")
            self.atualizarValor(endereco)
            if valor is not None:
                self.cache[endereco] = valor
                self.ram[endereco] = valor
            else:
                self.cache[endereco] = self.ram[endereco]
            self.aplicarPolitica(endereco)



    def aplicarPolitica(self, endereco):
        if self.politica == 'LRU':
            if endereco in self.lru: # Para o LRU, a ordem de uso é importante.
                self.lru.remove(endereco)  # Se o elemento acessado já estiver na fila, ele é removido da posição atual e colocado no final como o "Último da fila"
            self.lru.append(endereco)
        elif self.politica == 'FIFO': # Já o FIFO, a ordem de uso não importa
            if endereco not in self.fifo: # Se um elemento é acessado, a ordem a fila não se altera.
                self.fifo.append(endereco)
        elif self.politica == 'LFU': # Para o LFU, se o elemento é acessado, aumenta a sua contagem de uso dentro do dicionario.
            self.lfu[endereco] += 1

    def atualizarValor(self, novo_endereco):
        if len(self.cache) < self.tamanhoCache: # Serve para não realizar as alterações de remoção caso a fila ainda não esteja cheia
            return

        if self.politica == 'LRU':
            removido = self.lru.popleft() # Remove o primeiro elemento da fila
            print(f"Substituindo (LRU): {removido}")
        elif self.politica == 'FIFO':
            removido = self.fifo.popleft() # Remove o primeiro elemento da fila
            print(f"Substituindo (FIFO): {removido}")
        elif self.politica == 'LFU':
            removido = min(self.lfu, key=self.lfu.get) # Descobre o elemento com menor numero de acessos para que seja removido.
            print(f"Substituindo (LFU): {removido}")
            del self.lfu[removido]

        self.cache.pop(removido, None)

        if removido in self.lru:
            self.lru.remove(removido)
        if removido in self.fifo:
            self.fifo.remove(removido)


# Nesse caso, a politica deve ser passada como parâmetro da hora da criação, LFU, LRU ou FIFO
# O tamanho da ram e da cache também deve ser inicializada por parâmetro
cache = CacheAssociativa(tamanhoCache=3, tamanhoRam=10, politica='FIFO')

cache.printRam()
cache.printCache()

cache.buscarEndereço(1)

cache.printCache()


cache.buscarEndereço(2)
cache.buscarEndereço(3)

cache.printCache()

cache.buscarEndereço(1)  # aumenta frequência do 1
cache.buscarEndereço(4)  # vai disparar substituição
cache.buscarEndereço(2)  # se sobreviveu, aumenta freq

cache.printCache()

cache.buscarEndereço(5)

cache.printCache()